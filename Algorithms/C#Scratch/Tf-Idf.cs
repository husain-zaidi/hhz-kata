// TF-IDF Search Demo in C# (generated by gpt4.1)
// This script demonstrates TF-IDF vectorization and search over a set of sample documents, implemented from scratch.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

class TfIdfSearchDemo
{
    static List<string> documents = new List<string>
    {
        "The quick brown fox jumps over the lazy dog.",
        "Never jump over the lazy dog quickly.",
        "A fast brown fox leaps over sleeping dogs.",
        "Python and Java are popular programming languages.",
        "The dog is lazy but the fox is quick."
    };

    static List<string> docTitles = new List<string>
    {
        "Doc 1: Fox and Dog",
        "Doc 2: Jumping Dog",
        "Doc 3: Fast Fox",
        "Doc 4: Programming Languages",
        "Doc 5: Lazy Dog and Quick Fox"
    };

    static List<string> Tokenize(string text)
    {
        return Regex.Matches(text.ToLower(), @"\b\w+\b")
            .Cast<Match>()
            .Select(m => m.Value)
            .ToList();
    }

    static void Main1()
    {
        // Build vocabulary
        var vocabSet = new HashSet<string>();
        var docTokens = new List<List<string>>();
        foreach (var doc in documents)
        {
            var tokens = Tokenize(doc);
            docTokens.Add(tokens);
            foreach (var token in tokens) vocabSet.Add(token);
        }
        var vocab = vocabSet.OrderBy(w => w).ToList();
        var word2idx = vocab.Select((w, i) => new { w, i }).ToDictionary(x => x.w, x => x.i);

        // Compute TF matrix
        double[][] tfMatrix = docTokens.Select(tokens => ComputeTf(tokens, vocab, word2idx)).ToArray();

        // Compute DF
        double[] df = new double[vocab.Count];
        for (int i = 0; i < vocab.Count; i++)
            df[i] = docTokens.Count(tokens => tokens.Contains(vocab[i]));

        // Compute IDF
        double[] idf = new double[vocab.Count];
        for (int i = 0; i < vocab.Count; i++)
            idf[i] = Math.Log((1.0 + documents.Count) / (1.0 + df[i])) + 1.0;

        // Compute TF-IDF matrix
        double[][] tfidfMatrix = tfMatrix.Select(tf => tf.Zip(idf, (t, id) => t * id).ToArray()).ToArray();

        // Demonstration
        Search("quick fox", tfidfMatrix, vocab, word2idx, idf);
        Search("programming languages", tfidfMatrix, vocab, word2idx, idf);
        Search("lazy dog", tfidfMatrix, vocab, word2idx, idf);
    }

    static double[] ComputeTf(List<string> tokens, List<string> vocab, Dictionary<string, int> word2idx)
    {
        double[] tf = new double[vocab.Count];
        var counts = tokens.GroupBy(w => w).ToDictionary(g => g.Key, g => g.Count());
        foreach (var kv in counts)
        {
            int idx = word2idx[kv.Key];
            tf[idx] = (double)kv.Value / tokens.Count;
        }
        return tf;
    }

    static double[] VectorizeQuery(string query, List<string> vocab, Dictionary<string, int> word2idx, double[] idf)
    {
        var tokens = Tokenize(query);
        var tf = ComputeTf(tokens, vocab, word2idx);
        return tf.Zip(idf, (t, id) => t * id).ToArray();
    }

    static double CosineSimilarity(double[] v1, double[] v2)
    {
        double dot = 0, norm1 = 0, norm2 = 0;
        for (int i = 0; i < v1.Length; i++)
        {
            dot += v1[i] * v2[i];
            norm1 += v1[i] * v1[i];
            norm2 += v2[i] * v2[i];
        }
        if (norm1 == 0 || norm2 == 0) return 0.0;
        return dot / (Math.Sqrt(norm1) * Math.Sqrt(norm2));
    }

    static void Search(string query, double[][] tfidfMatrix, List<string> vocab, Dictionary<string, int> word2idx, double[] idf, int topN = 3)
    {
        var queryVec = VectorizeQuery(query, vocab, word2idx, idf);
        var scores = tfidfMatrix.Select(docVec => CosineSimilarity(docVec, queryVec)).ToArray();
        var ranked = scores.Select((score, idx) => new { score, idx })
            .OrderByDescending(x => x.score)
            .Take(topN)
            .ToList();
        Console.WriteLine($"\nSearch results for query: '{query}'\n{new string('=', 40)}");
        foreach (var r in ranked)
        {
            Console.WriteLine($"{docTitles[r.idx]} (Score: {r.score:F4})\n  {documents[r.idx]}\n");
        }
    }
}
